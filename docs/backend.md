

# DTOs, Models, etc

There are some common patterns for data objects in the backend:

1. They do not have behavior
2. `Model`'s exists as an integration: they are serializable input/output from the API
3. `SubjectDTOs`'s are the core data deinfitions of _Subject_ objects we operate on
4. `ActionSubjectDTOs`'s are _Action_'s on _Subject_, for instance _Update_ and are applied by Business Services
5. `ChangeEvent`'s are part of the `EventStore` infrastructure and are update actions applied to a _Subject_ that is EventStore-tracked

# Versioned Updates: EventStore, Event-based updates: Business Model, Cash Forecast, etc

The `EventStore` infrastructure is somewhere between Operational Transformation and CRDT's.

At it's core, the idea is that each edit in the interface is communicated as a `ChangeEvent` that has one or more `Operations`s to apply, no earlier than a given `VersionNumber`.

The _Subject_ is versioned by the server as `ChangeEvent`s are applied to it, stamping both the `ChangeEvent` and the _Subject_ with that version number. The client tracks and applies both versioned and local non-versioned events, but always applies versioned events before unversioned ones and performs the same loose conflict-resolution the server does. When in doubt, the server version number wins.

Clients are assigned an `Actor` id and a starting `seqNo` (sequence number). Every change generated by the client increments the local `seqNo` by the number of operations involved, and tracks the latest server-side `versionNumber` that was available when it was applied locally, so events can be applied in the client in order and presented to the server in order, even if the network goes down and long retries are needed.

When an event is submitted ot the server, it will be applied an receive a version number, then be returned to the client as an `Applied<ChangeEvent>`. The same change will also be broadcast by SignalR, the sender will ignore the update by recognizing it's ActorId on the update and assume it already has the response.

## Overall client flow:

API:

* Get a Full Update - gets the latest State DTO from the server (not the event stream), base of the FinalStore
* Get Updates Since - gets all events since a given server `VersionNumber` and plays them locally in the FinalStore against the base
* Send Update - sends a `ChangeEvent`, receives an `Applied` verison back with the version number, adds it to the Final store against the base
* SignalR - receives an event, if FinalStore is caught up to prior VersionNumber it applies to FinalStore, otherwise it calls GetUpdatesSince to catch up on the gap

Stores:

* FinalStore - the latest versioned DTO available from the server and/or playing events versioned by the server
* LocalStore - the events not yet sent to the server and the result of the FinalStore DTO + those events to create a locally updated version

## Caveats

The TypeScript front-end can handle things fully dynamically, the only code needed is defining the event and then the logic can track id's and apply events very easily.

The Server-side C# does not handle things dynamically, currently, and instead requires every event from the front-end to have explicit, hand-coded application logic on the server.

# Simple Updates: Studio Settings, Game Settings

Simpler DTOs use a very basic CRUD pattern for updates, instead of the more extensive EventStore setup.

* API: API's accept `ActionSubjectRequestModel`s and convert them into `ActionSubjectDTOs`, sending them to the BusinessService
* Business Service: Performs the _Action_ on the given _Subject_, using the persistence repo's to load/save values
* API: API signals (via signalr) that the subject has been updated - groups in SignalR are scoped specifically to studios and sub-topics and use that same key to allow the front-end clients to react only tot he ones they care about

